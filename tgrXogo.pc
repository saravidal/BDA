/*
 * Autores:
 * Daniel López López (d.lopez.lopez@udc.es)
 * Sara Vidal García (sara.vidal@udc.es) 
 * Universidade da Coruña
 *
 * BDA - Curso 2016-2017
 *
 * TGR - XOGOS
 */

#include<stdlib.h>
#include<stdio.h>
#include<string.h>
#include<time.h>
EXEC SQL INCLUDE SQLCA;

/*
 * Utilidades para menús e ler valores por teclado.  
 */
#define MAXLEN 20
void get_string(char *s, int maxlen){
	fgets(s,maxlen,stdin);
	int last = strlen(s) -1;
	if ( (s[last]=='\r') || (s[last]=='\n') )
		s[last] = '\0';
}

void get_password(char *s, int maxlen){
	system("stty -echo");
	get_string(s,maxlen);
	system("stty echo");
}

int get_int(){
	char s[MAXLEN];
	get_string(s,MAXLEN);
	return atoi(s);
}

float get_float(){
	char s[MAXLEN];
	get_string(s,MAXLEN);
	return atof(s);
}



/* Menú principal */

int menu()
{
  int opcion = -1;

  int MAXOPTS = 12; /* Número de opcións do menú */

  printf("Menu da aplicación de Xogos\n");
  printf("==================\n\n");
  printf(" 1. Listar Xogos\n");
  printf(" 2. Buscar Xogo\n");
  printf(" 3. Buscar Autor\n");
  printf(" 4. Engadir Critica\n");
  printf(" 5. Engadir Autor\n");
  printf(" 6. Engadir Xogo\n");
  printf(" 7. Eliminar Xogo\n");
  printf(" 8. Eliminar Autor\n");
  printf(" 9. Editar Datos Autor\n");
  printf("10. Votar positivamente\n");
  printf("11. Votar negativamente\n");
  printf("0. Sair\n");

  while ( (opcion < 0) || (opcion > MAXOPTS)){
      printf("OP> ");
      opcion=get_int();
  }
  return opcion;
}


void erroManager_conexion(char *usr){
	EXEC SQL WHENEVER SQLERROR CONTINUE;
	switch (sqlca.sqlcode){
		case -1017: printf("Credenciais de %s invalidas. Abortando conexion.\n", usr);
				break;
		case -1012: printf("Non estabas conectado. Saindo do programa.\n");
				break;
		default: printf("Estado: Código %d, Mensaxe: %.*s.\n",
	sqlca.sqlcode,
	sqlca.sqlerrm.sqlerrml,
	sqlca.sqlerrm.sqlerrmc);
	}
	exit(-1);
}

int errorManager_DML(){
	int retval = sqlca.sqlcode; 
	EXEC SQL WHENEVER SQLERROR CONTINUE;
	switch (sqlca.sqlcode){
		case -1: printf("Non podo insertar o artigo, o código xa existe.\n\n");

		default: printf("\nEstado: Código %d, Mensaxe: %.*s.\n",
		sqlca.sqlcode,
		sqlca.sqlerrm.sqlerrml,
		sqlca.sqlerrm.sqlerrmc);
	}
	EXEC SQL ROLLBACK; //Dependiendo del caso quiza no queremos hacer un rollback
	return retval;
}

/* Funcionalidadess de base de datos */

void conecta_bd(){
   	EXEC SQL WHENEVER SQLERROR DO erroManager_conexion(usuario);
   	EXEC SQL BEGIN DECLARE SECTION;
      		char usuario[30];
      		char clave[30];
   	EXEC SQL END DECLARE SECTION;

   	printf("Introduce as tuas credenciais de Oracle:\n");  
   	printf("Usuario: "); get_string(usuario,30);
   	printf("Clave: "); get_password(clave,30);
   	printf("\n\nConectando con Oracle...\n");
   
   	EXEC SQL CONNECT :usuario IDENTIFIED BY :clave;

	printf("\n\nConectado!\n\n");
}


void desconecta_bd(){
   EXEC SQL WHENEVER SQLERROR DO erroManager_conexion("");
   EXEC SQL COMMIT RELEASE;
}









void engadir_autor(){
	int erro = 0;		
	EXEC SQL WHENEVER SQLERROR DO erro=errorManager_DML();
   	
	EXEC SQL BEGIN DECLARE SECTION;
		int tipoxeral;
      		char id[25];
		char nome[50];
		char enlace[256];
		char tipo[30];
		int pausa;
   	EXEC SQL END DECLARE SECTION;
	
	printf("REXISTRO DE AUTORES\n\n");
	printf("Que clase de rexistro desexa facer:\n");
   	printf("(1)\tPersoa individual\n");
	printf("(2)\tGrupo\n");
	printf("Seleccione a opción que mais se axuste a vostede.");
	printf("\n\t> ");
	tipoxeral = get_int();

	if (tipoxeral == 1){
		printf("DATOS PERSOAIS:\n");
		strcpy(tipo, "PARTICULAR");
		printf("(*) DNI\n\t> ");
		get_string(id,25);
	}else{
		printf("DATOS DO GRUPO:\n");
		printf("(*) CIF ou identificador\n\t> ");
		get_string(id,25);
		printf("(*) Tipo (empresa, revista...)\n\t> ");
		get_string(tipo,30);
	}
	printf("(*) Nome\n\t> ");
	get_string(nome,50);
	printf("Enlace a sua paxina web\n\t> ");
	get_string(enlace,256);
   	
   	EXEC SQL INSERT INTO autor(idAutor,nome,enlace,tipo)
   	VALUES (:id, :nome, :enlace, :tipo);
   
	if(erro==0){
		EXEC SQL COMMIT;
		printf("\n\nAutor insertado con exito\n\n\n");
	}
	pausa = get_int();
}


void engadir_critica(){
	int erro = 0;		
	EXEC SQL WHENEVER SQLERROR DO erro=errorManager_DML();
   	
	EXEC SQL BEGIN DECLARE SECTION;
		int autor;
		char titulo[50];
		char data[128];
		time_t tempo;
		struct tm *tlocal;
		int puntuacion;
		char descricion[500];
		int xogo;
		char idAutor[25];
		int pausa;
   	EXEC SQL END DECLARE SECTION;

	printf("CRITICAS\n\n");
	printf("Autor xa rexistrado ou novo autor?:\n");
   	printf("(1)\tNovo\n");
	printf("(2)\tExistente\n");
	printf("\n\t> ");
	autor = get_int();

	if (autor == 1){
		engadir_autor();
		printf("CRITICAS\n\n");
	}	
	printf("Identificador do autor\n\t> ");
	get_string(idAutor,25);
	printf("(*) Codigo do xogo\n\t> ");
	xogo = get_int();
	printf("(*) Titulo da critica\n\t> ");
	get_string(titulo,50);
	printf("(*) Puntuacion sobre 100:\n\t>");
	puntuacion = get_int();
	printf("Descricion (un unico paragrafo)\n\t> ");
	get_string(descricion,500);
	tempo = time(0);
	tlocal = localtime(&tempo);
	strftime(data,128,"%d/%m/%y",tlocal);	
   	
   	EXEC SQL INSERT INTO critica(tituloCritic,data,puntuacion,descricion,xogo,autor)
   	VALUES (:titulo, :data, :puntuacion, :descricion, :xogo, :idAutor);
   
	if(erro==0){
		EXEC SQL COMMIT;
		printf("\n\nCritica insertada con exito\n\n\n");
	}
	pausa = get_int();
}


void engadir_xogo(){
	int erro = 0;		
	EXEC SQL WHENEVER SQLERROR DO erro=errorManager_DML();
   	
	EXEC SQL BEGIN DECLARE SECTION;
		char tituloXogo[50];
		char dia[4];
		char mes[4];
		char ano[6];
		char dataDeSaida[11];
		int votosPositivos,votosNegativos,pausa;
   	EXEC SQL END DECLARE SECTION;
	
	printf("REXISTRO DE XOGOS\n\n");
	printf("(*) Titulo\n\t> ");
	get_string(tituloXogo,50);
	printf("Data de saida:\n\t>Dia(dd): ");
	get_string(dia,4);
	printf("\n\t>Mes(mm): ");
	get_string(mes,4);
	printf("\n\t>Ano(yyyy): ");
	get_string(ano,6);
	strcpy(dataDeSaida,dia);
	strcat(dataDeSaida,"/");
	strcat(dataDeSaida,mes);
	strcat(dataDeSaida,"/");
	strcat(dataDeSaida,ano);
   	votosPositivos = 0; 
	votosNegativos = 0;

   	EXEC SQL INSERT INTO xogo(tituloXogo,dataDeSaida,votosPositivos,votosNegativos)
   	VALUES (:tituloXogo, :dataDeSaida, :votosPositivos, :votosNegativos);
   
	if(erro==0){
		EXEC SQL COMMIT;
		printf("\n\nXogo insertado con exito\n\n\n");
	}
	pausa = get_int();
}



void eliminar_autor()
{
	int erro = 0;		
	EXEC SQL WHENEVER SQLERROR DO erro=errorManager_DML();

   	EXEC SQL BEGIN DECLARE SECTION;
      		char id[25];
		int pausa;
	EXEC SQL END DECLARE SECTION;

	printf("ELIMINACION DE AUTORES\n\n");
	printf("Identificador do autor\n\t> "); 
	get_string(id,25);

	EXEC SQL DELETE FROM autor 
		WHERE idAutor = :id;

	if (sqlca.sqlerrd[2] > 0)
		printf("\nAutor eliminado con exito\n\n\n");
	else
		printf("\nAutor non eliminado\n\n\n");

	if (!erro) 
		EXEC SQL COMMIT;

	pausa = get_int();
}


void eliminar_xogo()
{
	int erro = 0;		
	EXEC SQL WHENEVER SQLERROR DO erro=errorManager_DML();

   	EXEC SQL BEGIN DECLARE SECTION;
      		int cod,pausa;
	EXEC SQL END DECLARE SECTION;

	printf("ELIMINACION DE XOGOS\n\n");
	printf("Codigo do xogo\n\t> "); 
	cod = get_int();

	EXEC SQL DELETE FROM xogo 
		WHERE codXogo = :cod;

	if (sqlca.sqlerrd[2] > 0)
		printf("\nXogo eliminado con exito\n\n\n");
	else
		printf("\nXogo non eliminado\n\n\n");

	if (!erro) 
		EXEC SQL COMMIT;

	pausa = get_int();	
}




void buscarCritica() {
	int erro = 0;		
	EXEC SQL WHENEVER SQLERROR DO erro=errorManager_DML();
	
	printf("Función buscarCritica().\n");
   	EXEC SQL BEGIN DECLARE SECTION;
        int codCritic;
        char tituloCritic[51];
        char autor[51];
        int puntuacion;
        char dataC[11];
        short dataC_ind;
        char descripcion[501];
        char xogo[51];
	EXEC SQL END DECLARE SECTION;

        printf("Introduzca o código da crítica[0 para sair]: ");
   	codCritic = get_int();

        EXEC SQL SET TRANSACTION READ ONLY;

	//Control de salida
        
	if(codCritic == 0){
		EXEC SQL COMMIT;
                return;
        }

        EXEC SQL SELECT codCritic, tituloCritic, (SELECT tituloXogo FROM xogo WHERE codXogo=c.xogo), (SELECT nome FROM autor WHERE idAutor=c.autor), puntuacion,descricion, TO_CHAR(data, 'dd/mm/yyyy')
                INTO :codCritic,:tituloCritic,:xogo,:autor,:puntuacion,:descripcion,:dataC:dataC_ind
        FROM critica c
        WHERE codCritic=:codCritic ;

	if(sqlca.sqlcode == 1403){
		printf("Non hai criticas con ese código.");
	}else{
		printf("--Criticas--\n--Codigo--\t--Titulo--\t--Autor--\t--Puntuacion--\n");
		printf(" %d\t%s\t%s\t%s\t%d\n",codCritic,tituloCritic,xogo,autor,puntuacion);
		printf("-----------------------------------------------------------------\n");
		printf("%s\n",descripcion);
		if(dataC_ind==0)printf("Datado de: %s\n",dataC);
	}
	if(!erro) EXEC SQL COMMIT;
}

void listarCriticasXogo( int id)
{
        int erro = 0;		
	EXEC SQL WHENEVER SQLERROR DO erro=errorManager_DML();
	
	printf("Función listarCriticasXogo().\n");
   	EXEC SQL BEGIN DECLARE SECTION;
      	int identificador;
        int codCritic;
        char tituloCritic[51];
        char autor[51];
        int puntuacion;
	EXEC SQL END DECLARE SECTION;

        identificador=id;
        
        //strncpy(identificador, id, 25);

	EXEC SQL SET TRANSACTION READ ONLY;	
	
                EXEC SQL DECLARE cursor_critics CURSOR FOR
                SELECT codCritic, tituloCritic, (SELECT nome FROM autor WHERE idAutor=c.autor), puntuacion 
                FROM critica c 
		WHERE xogo=:identificador;

	EXEC SQL OPEN cursor_critics;	
	EXEC SQL WHENEVER NOT FOUND DO BREAK;
	while(1) {
		EXEC SQL FETCH cursor_critics
		INTO :codCritic,:tituloCritic,:autor,:puntuacion;
		if(sqlca.sqlcode == 1403){
			printf("Non hai criticas para este xogo.\n");
		}else{
			printf("--Criticas--\n--Codigo--\t--Titulo--\t--Autor--\t--Puntuacion--\n");
			printf(" %d\t%s\t%s\t%d\n",codCritic,tituloCritic,autor,puntuacion);
		}
	}
        
        EXEC SQL WHENEVER NOT FOUND CONTINUE;
	printf("Criticas atopados: %d.\n", sqlca.sqlerrd[2]);
	EXEC SQL CLOSE cursor_critics;
        
        if(!erro) EXEC SQL COMMIT;
        
        buscarCritica();
}

void listarCriticasAutor(char *id)
{
        int erro = 0;		
	EXEC SQL WHENEVER SQLERROR DO erro=errorManager_DML();
	
	printf("Función listarCriticasAutor().\n");
   	EXEC SQL BEGIN DECLARE SECTION;
      	char patron[28];
        int codCritic;
        char tituloCritic[51];
        char xogo[51];
        int puntuacion;
	EXEC SQL END DECLARE SECTION;

        //identificador=id;

        //printf("%s\n", id);
        
        //strncpy(identificador, id, 26);
        //int last = strlen(identificador) -1;
	//if ( (identificador[last]=='\r') || (identificador[last]=='\n') )
		//identificador[26] = 0;
        //printf("%s\n", identificador);

	strcpy(patron, "%");
	strcat(patron, id);
	strcat(patron, "%");


	EXEC SQL SET TRANSACTION READ ONLY;	
	
		EXEC SQL DECLARE cursor_criticsA CURSOR FOR
                SELECT codCritic, tituloCritic, (SELECT tituloXogo FROM xogo WHERE codXogo=c.xogo), puntuacion 
                FROM critica c 
		WHERE autor LIKE :patron;

	EXEC SQL OPEN cursor_criticsA;	
	EXEC SQL WHENEVER NOT FOUND DO BREAK;
	while(1) {
		EXEC SQL FETCH cursor_criticsA
		INTO :codCritic,:tituloCritic,:xogo,:puntuacion;
		if(sqlca.sqlcode == 1403){
			printf("Non hai criticas para este autor.\n");
		}else{
			printf("--Criticas--\n--Codigo--\t--Titulo--\t--Xogo--\t--Puntuacion--\n");
			printf(" %d\t%s\t%s\t%d\n",codCritic,tituloCritic,xogo,puntuacion);
		}
	}
        
        EXEC SQL WHENEVER NOT FOUND CONTINUE;
	printf("Criticas atopados: %d.\n", sqlca.sqlerrd[2]);
	EXEC SQL CLOSE cursor_criticsA;
        
        if(!erro) EXEC SQL COMMIT;
        
        buscarCritica();
}

void buscarXogoCodigo()
{
	int erro = 0;		
	EXEC SQL WHENEVER SQLERROR DO erro=errorManager_DML();
	
	printf("Función buscarXogoCodigo().\n");
   	EXEC SQL BEGIN DECLARE SECTION;
      	int codXogo;
	char tituloXogo[51];
	char dataDeSaida[11];
	short dataDeSaida_ind;
        int votosPositivos;
        int votosNegativos;
        int notaMedia;
	EXEC SQL END DECLARE SECTION;

	EXEC SQL SET TRANSACTION READ ONLY;	

	printf("Introduzca o código do xogo[0 para sair]: ");
   	codXogo=get_int();

	//Control de salida
	if (codXogo==0){
		EXEC SQL COMMIT;
                return;
        }
	EXEC SQL SELECT codXogo,tituloXogo,TO_CHAR(dataDeSaida, 'dd/mm/yyyy')   ,votosPositivos,votosNegativos,(SELECT AVG(puntuacion) FROM critica WHERE xogo=x.codXogo) 
		INTO :codXogo,:tituloXogo,:dataDeSaida:dataDeSaida_ind,:votosPositivos,:votosNegativos,:notaMedia
                FROM xogo x
		WHERE codXogo=:codXogo;

	

	if(sqlca.sqlcode == 1403)	
		printf("No se encontró el código indicado.\n");
	else
                printf("--Xogos--\n--Codigo--\t--Titulo--\t--Data de saida--\t--Votos Positivos--\t--Votos Negativos--\t--Nota Media--\n");
                if(dataDeSaida_ind == 0)
                        printf(" %d\t%s\t%s\t%d\t%d\t%d\n",codXogo,tituloXogo,dataDeSaida,votosPositivos,votosNegativos,notaMedia);
                else
                        printf(" %d\t%s\tSen data\t%d\t%d\t%d\n",codXogo,tituloXogo,votosPositivos,votosNegativos,notaMedia);	
        if(!erro) EXEC SQL COMMIT;
        
        listarCriticasXogo(codXogo);

}

void buscarXogoTitulo()
{
	int erro = 0;		
	EXEC SQL WHENEVER SQLERROR DO erro=errorManager_DML();
	
	printf("Función buscarXogoCodigo().\n");
   	EXEC SQL BEGIN DECLARE SECTION;
      	int codXogo;
        char tituloXogo[51], patron[53];
        char dataDeSaida[11];
        short dataDeSaida_ind;
        int votosPositivos;
        int votosNegativos;
        int notaMedia;
	EXEC SQL END DECLARE SECTION;

	EXEC SQL SET TRANSACTION READ ONLY;	

	printf("Introduzca o titulo do xogo: ");
   	get_string(tituloXogo,50);

        strcpy(patron, "%");
	strcat(patron, tituloXogo);
	strcat(patron, "%");

	EXEC SQL SELECT codXogo,tituloXogo,TO_CHAR(dataDeSaida, 'dd/mm/yyyy'),votosPositivos,votosNegativos,(SELECT AVG(puntuacion) FROM critica WHERE xogo=x.codXogo) 
		INTO :codXogo,:tituloXogo,:dataDeSaida:dataDeSaida_ind,:votosPositivos,:votosNegativos,:notaMedia
                FROM xogo x 
		WHERE tituloXogo LIKE :patron;

	

	if(sqlca.sqlcode == 1403)	
		printf("No se encontró el titulo indicado.\n");
	else
                printf("--Xogos--\n--Codigo--\t--Titulo--\t--Data de saida--\t--Votos Positivos--\t--Votos Negativos--\t--Nota Media--\n");
                if(dataDeSaida_ind == 0)
                        printf(" %d\t%s\t%s\t%d\t%d\t%d\n",codXogo,tituloXogo,dataDeSaida,votosPositivos,votosNegativos,notaMedia);
                else
                        printf(" %d\t%s\tSen data\t%d\t%d\t%d\n",codXogo,tituloXogo,votosPositivos,votosNegativos,notaMedia);	
        if(!erro) EXEC SQL COMMIT;
        
        listarCriticasXogo(codXogo);

}

void buscarAutor()
{
	int erro = 0;		
	EXEC SQL WHENEVER SQLERROR DO erro=errorManager_DML();
	
	printf("Función buscarAutor().\n");
   	EXEC SQL BEGIN DECLARE SECTION;
      	char idAutor[26];
        char nome[51], patron[53];
	char enlace[257];
	short enlace_ind;
        char tipo[31];
	EXEC SQL END DECLARE SECTION;

	EXEC SQL SET TRANSACTION READ ONLY;	

	printf("Introduzca o nome do autor: ");
   	get_string(nome,50);

 	strcpy(patron, "%");
	strcat(patron, nome);
	strcat(patron, "%");

	EXEC SQL SELECT idAutor, nome, enlace, tipo
                INTO :idAutor,:nome,:enlace:enlace_ind,:tipo
                FROM autor 
		WHERE nome LIKE :patron;

	

	if(sqlca.sqlcode == 1403)	
		printf("No se encontró el autor indicado.\n");
	else
                printf("--Autor--\n--Codigo--\t--Nome--\t--Enlace--\t--Tipo--\n");
                if(enlace_ind == 0)
                        printf(" %s\t%s\t%s\t%s\n",idAutor,nome,enlace,tipo);
                else
                        printf(" %s\t%s\tSen enlace\t%s\n",idAutor,nome,tipo);	
        if(!erro) EXEC SQL COMMIT;
        
        listarCriticasAutor(idAutor);
}


void listarXogos()
{
	int erro = 0;		
	EXEC SQL WHENEVER SQLERROR DO erro=errorManager_DML();
	
	printf("Función listarXogos().\n");
   	EXEC SQL BEGIN DECLARE SECTION;
      	int codXogo;
	char tituloXogo[51];
	char dataDeSaida[11];
	short dataDeSaida_ind;
        int votosPositivos;
        int votosNegativos;
        int notaMedia;
	EXEC SQL END DECLARE SECTION;

	EXEC SQL SET TRANSACTION READ ONLY;	

	EXEC SQL DECLARE cursor_elementos CURSOR FOR
		SELECT codXogo,tituloXogo, TO_CHAR(dataDeSaida, 'dd/mm/yyyy'),votosPositivos,votosNegativos,(SELECT AVG(puntuacion) FROM critica WHERE xogo=x.codXogo) 
		FROM xogo x;
	
	EXEC SQL OPEN cursor_elementos;	
	EXEC SQL WHENEVER NOT FOUND DO BREAK;

	while(1) {
		EXEC SQL FETCH cursor_elementos
		INTO :codXogo,:tituloXogo,:dataDeSaida:dataDeSaida_ind,:votosPositivos,:votosNegativos,:notaMedia;
		if(sqlca.sqlcode == 1403)	
			printf("Non hai xogos.\n");
		else
                        printf("--Xogos--\n--Codigo--\t--Titulo--\t--Data de saida--\t--Votos Positivos--\t--Votos Negativos--\t--Nota Media--\n");
			if(dataDeSaida_ind == 0)
				printf(" %d\t%s\t%s\t%d\t%d\t%d\n",codXogo,tituloXogo,dataDeSaida,votosPositivos,votosNegativos,notaMedia);
			else
				printf(" %d\t%s\tSen data\t%d\t%d\t%d\n",codXogo,tituloXogo,votosPositivos,votosNegativos,notaMedia);
	}
         
	EXEC SQL WHENEVER NOT FOUND CONTINUE;
	printf("Xogos atopados: %d.\n", sqlca.sqlerrd[2]);
	EXEC SQL CLOSE cursor_elementos;

	if(!erro) EXEC SQL COMMIT;
	
	buscarXogoCodigo();
}


void mostrar_votos(int codXogo){
	int erro = 0;
	EXEC SQL WHENEVER SQLERROR CONTINUE;
	
	EXEC SQL BEGIN DECLARE SECTION;
		int cod,votosP,votosN;
		char titulo[50];
	EXEC SQL END DECLARE SECTION; 

	EXEC SQL SET TRANSACTION READ ONLY;

	cod = codXogo;

	EXEC SQL SELECT tituloXogo, votosPositivos, votosNegativos  
	INTO :titulo,:votosP, :votosN
	FROM xogo
	WHERE codXogo = :cod;
	
	printf("\n%s",titulo);
	printf("\n\tVotos positivos: %d",votosP);
	printf("\n\tVotos negativos: %d",votosN);
	
	if (!erro)
		EXEC SQL COMMIT;
		
}


void editar_autor()
{
	int erro = 0;		
	EXEC SQL WHENEVER SQLERROR DO erro=errorManager_DML();
	
   	EXEC SQL BEGIN DECLARE SECTION;
      		char idAutor[25];
		char nome[50];
		char enlace[256];
		int pausa;
	EXEC SQL END DECLARE SECTION;
	
	//EXEC SQL SET TRANSACTION ISOLATION LEVEL SERIALIZABLE;

	printf("EDITAR DATOS DE AUTOR\n\n");
	printf("Identificador do autor a modificar> "); 
	get_string(idAutor,25);
	printf("\nInserte os novos datos:\n\n");
	printf("(*) Nome\n\t> ");
	get_string(nome,50);
	printf("Enlace a sua paxina web\n\t> ");
	get_string(enlace,256);

	EXEC SQL UPDATE autor
		SET nome = :nome, enlace =:enlace
		WHERE idAutor = :idAutor;

	if(!erro){
		EXEC SQL COMMIT;
		printf("\n\nDatos editados con exito!\n\n\n");	
	}
	pausa = get_int();
}

void votar_positivamente()
{
	int erro = 0;		
	EXEC SQL WHENEVER SQLERROR DO erro=errorManager_DML();
	
   	EXEC SQL BEGIN DECLARE SECTION;
      		int codXogo,pausa;
	EXEC SQL END DECLARE SECTION;
	
	//EXEC SQL SET TRANSACTION ISOLATION LEVEL SERIALIZABLE;

	printf("VOTAR POSITIVAMENTE\n\n");
	printf("Código do xogo> "); 
	codXogo = get_int();

	EXEC SQL UPDATE xogo
		SET votosPositivos = votosPositivos + 1
		WHERE codXogo = :codXogo;

	if(!erro){
		EXEC SQL COMMIT;
		mostrar_votos(codXogo);
		printf("\n\nGracias por votar!\n\n\n");	
	}
	pausa = get_int();
}


void votar_negativamente()
{
	int erro = 0;		
	EXEC SQL WHENEVER SQLERROR DO erro=errorManager_DML();
	
   	EXEC SQL BEGIN DECLARE SECTION;
      		int codXogo,pausa;
	EXEC SQL END DECLARE SECTION;
	
	//EXEC SQL SET TRANSACTION ISOLATION LEVEL SERIALIZABLE;

	printf("VOTAR NEGATIVAMENTE\n\n");
	printf("Código do xogo> "); 
	codXogo = get_int();

	EXEC SQL UPDATE xogo
		SET votosNegativos = votosNegativos + 1
		WHERE codXogo = :codXogo;

	if(!erro){
		EXEC SQL COMMIT;
		mostrar_votos(codXogo);
		printf("\n\nGracias por votar!\n\n\n");	
	}

	pausa = get_int();
}


/* Función principal */
int main()
{
  conecta_bd();

  int op;

  while ( (op=menu()) != 0){
       switch(op){
            case 1: listarXogos(); break;
            case 2: buscarXogoTitulo(); break;
            case 3: buscarAutor(); break;
	    case 4: engadir_critica(); break;
	    case 5: engadir_autor(); break;
	    case 6: engadir_xogo(); break;
	    case 7: eliminar_xogo(); break;
	    case 8: eliminar_autor(); break;
	    case 9: editar_autor(); break;
	    case 10: votar_positivamente(); break;
	    case 11: votar_negativamente(); break;
       }

  }
 


 desconecta_bd(); 

 return 0;
}



